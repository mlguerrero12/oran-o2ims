// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/openshift-kni/oran-o2ims/internal/service/common/api/generated"
)

// Defines values for AlarmDefinitionAlarmChangeType.
const (
	ADDED    AlarmDefinitionAlarmChangeType = "ADDED"
	DELETED  AlarmDefinitionAlarmChangeType = "DELETED"
	MODIFIED AlarmDefinitionAlarmChangeType = "MODIFIED"
)

// Defines values for AlarmDefinitionClearingType.
const (
	AUTOMATIC AlarmDefinitionClearingType = "AUTOMATIC"
	MANUAL    AlarmDefinitionClearingType = "MANUAL"
)

// Defines values for AlarmDefinitionManagementInterfaceId.
const (
	AlarmDefinitionManagementInterfaceIdO2IMS AlarmDefinitionManagementInterfaceId = "O2IMS"
)

// Defines values for AlarmDictionaryManagementInterfaceId.
const (
	AlarmDictionaryManagementInterfaceIdO2IMS AlarmDictionaryManagementInterfaceId = "O2IMS"
)

// Defines values for ResourceTypeResourceClass.
const (
	ResourceTypeResourceClassCOMPUTE    ResourceTypeResourceClass = "COMPUTE"
	ResourceTypeResourceClassNETWORKING ResourceTypeResourceClass = "NETWORKING"
	ResourceTypeResourceClassSTORAGE    ResourceTypeResourceClass = "STORAGE"
	ResourceTypeResourceClassUNDEFINED  ResourceTypeResourceClass = "UNDEFINED"
)

// Defines values for ResourceTypeResourceKind.
const (
	ResourceTypeResourceKindLOGICAL   ResourceTypeResourceKind = "LOGICAL"
	ResourceTypeResourceKindPHYSICAL  ResourceTypeResourceKind = "PHYSICAL"
	ResourceTypeResourceKindUNDEFINED ResourceTypeResourceKind = "UNDEFINED"
)

// AlarmDefinition Information about an alarm definition.
type AlarmDefinition struct {
	// AlarmAdditionalFields List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	AlarmAdditionalFields map[string]interface{} `json:"alarmAdditionalFields"`

	// AlarmChangeType Indicates the type of change that occurred during the alarm last change; added, deleted, modified.
	AlarmChangeType AlarmDefinitionAlarmChangeType `json:"alarmChangeType"`

	// AlarmDefinitionId Provides a unique identifier of the alarm being raised. This is the Primary Key into the Alarm Dictionary
	AlarmDefinitionId openapi_types.UUID `json:"alarmDefinitionId"`

	// AlarmDescription Provides a longer descriptive meaning of the alarm condition and a description of the consequences of the
	// alarm condition. This is intended to be read by an operator to give an idea of what happened and a sense of
	// the effects, consequences, and other impacted areas of the system.
	AlarmDescription string `json:"alarmDescription"`

	// AlarmLastChange Indicates the Alarm Dictionary Version in which this alarm last changed.
	AlarmLastChange string `json:"alarmLastChange"`

	// AlarmName Provides short name for the alarm
	AlarmName string `json:"alarmName"`

	// ClearingType Identifies whether alarm is cleared automatically or manually.
	ClearingType AlarmDefinitionClearingType `json:"clearingType"`

	// ManagementInterfaceId List of management interface over which alarms are transmitted for this Entity Type.
	// RESTRICTION: For the O-Cloud IMS Services this value is limited to O2IMS.
	ManagementInterfaceId []AlarmDefinitionManagementInterfaceId `json:"managementInterfaceId"`

	// PkNotificationField Identifies which field or list of fields in the alarm notification contains the primary key (PK) into the
	// Alarm Dictionary for this interface; i.e. which field contains the Alarm Definition ID.
	PkNotificationField []string `json:"pkNotificationField"`

	// ProposedRepairActions Provides guidance for proposed repair actions.
	ProposedRepairActions string `json:"proposedRepairActions"`
}

// AlarmDefinitionAlarmChangeType Indicates the type of change that occurred during the alarm last change; added, deleted, modified.
type AlarmDefinitionAlarmChangeType string

// AlarmDefinitionClearingType Identifies whether alarm is cleared automatically or manually.
type AlarmDefinitionClearingType string

// AlarmDefinitionManagementInterfaceId defines model for AlarmDefinition.ManagementInterfaceId.
type AlarmDefinitionManagementInterfaceId string

// AlarmDictionary Information about an alarm dictionary.
type AlarmDictionary struct {
	AlarmDefinition []AlarmDefinition `json:"alarmDefinition"`

	// AlarmDictionarySchema Version of the Alarm Dictionary Schema to which this alarm dictionary conforms.
	AlarmDictionarySchema string `json:"alarmDictionarySchema"`

	// AlarmDictionaryVersion Version of the Alarm Dictionary. Version is vendor defined such that the version of the dictionary can be
	// associated with a specific version of the software delivery of this product.
	AlarmDictionaryVersion string `json:"alarmDictionaryVersion"`

	// EntityType O-RAN entity type emitting the alarm: This shall be unique per vendor ResourceType.model and
	// ResourceType.version
	EntityType string `json:"entityType"`

	// ManagementInterfaceId List of management interface over which alarms are transmitted for this Entity Type.
	// RESTRICTION: For the O-Cloud IMS Services this value is limited to O2IMS.
	ManagementInterfaceId []AlarmDictionaryManagementInterfaceId `json:"managementInterfaceId"`

	// PkNotificationField Identifies which field or list of fields in the alarm notification contains the primary key (PK) into the
	// Alarm Dictionary for this interface; i.e. which field contains the Alarm Definition ID.
	PkNotificationField []string `json:"pkNotificationField"`

	// Vendor Vendor of the Entity Type to whom this Alarm Dictionary applies. This should be the same value as in the
	// ResourceType.vendor attribute
	Vendor string `json:"vendor"`
}

// AlarmDictionaryManagementInterfaceId defines model for AlarmDictionary.ManagementInterfaceId.
type AlarmDictionaryManagementInterfaceId string

// DeploymentManager Information about a deployment manager.
type DeploymentManager struct {
	// Capabilities Information about the capabilities supported by the Deployment Manager and its set of deployment management
	// services based on the resources allocated to the Deployment Manager.
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`

	// Capacity Information about the available, allocated and reserved capacity of O-Cloud Resources allocated to the
	// Deployment Manager.
	Capacity *map[string]interface{} `json:"capacity,omitempty"`

	// DeploymentManagerId Identifier for the Deployment Manager. This identifier is allocated by the O-Cloud.
	DeploymentManagerId *openapi_types.UUID `json:"deploymentManagerId,omitempty"`

	// Description Human readable description of the deployment manager
	Description *string `json:"description,omitempty"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related Deployment Manager.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// Name Human readable description of the deployment manager
	Name *string `json:"name,omitempty"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId *openapi_types.UUID `json:"oCloudId,omitempty"`

	// ServiceUri The fully qualified URI to a Deployment Management server for O2dms services. Since the O2dms provides
	// multiple services, this entry is for the {apiRoot} only.
	ServiceUri *string `json:"serviceUri,omitempty"`

	// SupportedLocations List of globalLocationIDs that were assigned to the OCloud Site(s) which this Deployment Manager supports.
	SupportedLocations *[]string `json:"supportedLocations,omitempty"`
}

// OCloudInfo defines model for OCloudInfo.
type OCloudInfo struct {
	// Description Human readable description of the O-Cloud as provided by the SMO at cloud genesis.
	Description *string                 `json:"description,omitempty"`
	Extensions  *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalCloudId Identifier of the O-Cloud instance assigned by the SMO. This identifier is globally unique across O-Cloud instances known to the SMO. This value was provided by the SMO at cloud genesis and is stored in the O-Cloud IMS Inventory.
	GlobalCloudId *openapi_types.UUID `json:"globalCloudId,omitempty"`

	// Name Human readable name of the O-Cloud as identified by the SMO at cloud genesis.
	Name *string `json:"name,omitempty"`

	// OCloudId Identifier of the O-Cloud instance. Internally generated within an O-Cloud instance.
	OCloudId *openapi_types.UUID `json:"oCloudId,omitempty"`

	// ServiceUri The URI root to all services provided by the O2ims interface. Inventory is one of these services.
	ServiceUri *string `json:"serviceUri,omitempty"`
}

// Resource Information about a resource.
type Resource struct {
	// Description Human readable description of the resource.
	Description string `json:"description"`

	// Elements The resource might be composed of smaller resources or other resource instances of a different type
	Elements []Resource `json:"elements"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource.
	Extensions map[string]interface{} `json:"extensions"`

	// GlobalAssetId Identifier or serial number of the resource, if available. It is required only if the resource has been
	// identified during its addition to the cloud as a reportable asset in the SMO inventory.
	GlobalAssetId string `json:"globalAssetId"`

	// Groups Keywords denoting groups a resource belongs to.
	Groups []string `json:"groups"`

	// ResourceId Identifier for the Resource. This identifier is allocated by the O-Cloud.
	ResourceId     openapi_types.UUID `json:"resourceId"`
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`

	// ResourceTypeId Identifier for the Resource Type of this resource.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Tags Keywords describing or classifying the resource instance
	Tags []string `json:"tags"`
}

// ResourcePool Information about a resource pool.
type ResourcePool struct {
	// Description Human readable description of the resource pool.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource pool.
	Extensions *map[string]interface{} `json:"extensions,omitempty"`

	// GlobalLocationId This identifier is copied from the O-Cloud Id assigned by the SMO during the O-Cloud deployment
	GlobalLocationId openapi_types.UUID `json:"globalLocationId"`

	// Location Information about the geographical location of the resource pool as detected by the O-Cloud.
	Location *string `json:"location,omitempty"`

	// Name Human readable name of the resource pool.
	Name string `json:"name"`

	// OCloudId Identifier for the containing O-Cloud.
	OCloudId openapi_types.UUID `json:"oCloudId"`

	// ResourcePoolId Identifier for the Resource Pool in the O-Cloud instance. This identifier is allocated by the O-Cloud.
	ResourcePoolId openapi_types.UUID `json:"resourcePoolId"`
}

// ResourceType Information about a resource type.
type ResourceType struct {
	AlarmDictionary map[string]interface{} `json:"alarmDictionary"`

	// Description Human readable description of the resource type.
	Description string `json:"description"`

	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related resource type.
	Extensions map[string]interface{} `json:"extensions"`

	// Model Information about the model of the resource as defined by its provider.
	Model string `json:"model"`

	// Name Human readable name of the resource type.
	Name string `json:"name"`

	// ResourceClass Functional role of the resource type within the cloud.
	ResourceClass ResourceTypeResourceClass `json:"resourceClass"`

	// ResourceKind Value describing “physicality” of the resource type.
	ResourceKind ResourceTypeResourceKind `json:"resourceKind"`

	// ResourceTypeId Identifier for the Resource Type. This identifier is allocated by the O-Cloud.
	ResourceTypeId openapi_types.UUID `json:"resourceTypeId"`

	// Vendor Provider of the Resource.
	Vendor string `json:"vendor"`

	// Version Version or generation of the resource as defined by its provider.
	Version string `json:"version"`
}

// ResourceTypeResourceClass Functional role of the resource type within the cloud.
type ResourceTypeResourceClass string

// ResourceTypeResourceKind Value describing “physicality” of the resource type.
type ResourceTypeResourceKind string

// DeploymentManagerId defines model for deploymentManagerId.
type DeploymentManagerId = string

// ResourceId defines model for resourceId.
type ResourceId = string

// ResourcePoolId defines model for resourcePoolId.
type ResourcePoolId = string

// ResourceTypeId defines model for resourceTypeId.
type ResourceTypeId = string

// GetAllVersionsParams defines parameters for GetAllVersions.
type GetAllVersionsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCloudInfoParams defines parameters for GetCloudInfo.
type GetCloudInfoParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetMinorVersionsParams defines parameters for GetMinorVersions.
type GetMinorVersionsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDeploymentManagersParams defines parameters for GetDeploymentManagers.
type GetDeploymentManagersParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetDeploymentManagerParams defines parameters for GetDeploymentManager.
type GetDeploymentManagerParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetResourcePoolsParams defines parameters for GetResourcePools.
type GetResourcePoolsParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetResourceTypesParams defines parameters for GetResourceTypes.
type GetResourceTypesParams struct {
	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllVersions request
	GetAllVersions(ctx context.Context, params *GetAllVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudInfo request
	GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinorVersions request
	GetMinorVersions(ctx context.Context, params *GetMinorVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManagers request
	GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentManager request
	GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePools request
	GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcePool request
	GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceTypes request
	GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllVersions(ctx context.Context, params *GetAllVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudInfo(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinorVersions(ctx context.Context, params *GetMinorVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinorVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManagers(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentManager(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentManagerRequest(c.Server, deploymentManagerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePools(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcePool(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcePoolRequest(c.Server, resourcePoolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, resourcePoolId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourcePoolId, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceTypes(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, resourceTypeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllVersionsRequest generates requests for GetAllVersions
func NewGetAllVersionsRequest(server string, params *GetAllVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudInfoRequest generates requests for GetCloudInfo
func NewGetCloudInfoRequest(server string, params *GetCloudInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMinorVersionsRequest generates requests for GetMinorVersions
func NewGetMinorVersionsRequest(server string, params *GetMinorVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagersRequest generates requests for GetDeploymentManagers
func NewGetDeploymentManagersRequest(server string, params *GetDeploymentManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentManagerRequest generates requests for GetDeploymentManager
func NewGetDeploymentManagerRequest(server string, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentManagerId", runtime.ParamLocationPath, deploymentManagerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/deploymentManagers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolsRequest generates requests for GetResourcePools
func NewGetResourcePoolsRequest(server string, params *GetResourcePoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcePoolRequest generates requests for GetResourcePool
func NewGetResourcePoolRequest(server string, resourcePoolId ResourcePoolId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, resourcePoolId ResourcePoolId, params *GetResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourcePoolId ResourcePoolId, resourceId ResourceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcePoolId", runtime.ParamLocationPath, resourcePoolId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourcePools/%s/resources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypesRequest generates requests for GetResourceTypes
func NewGetResourceTypesRequest(server string, params *GetResourceTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, resourceTypeId ResourceTypeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceTypeId", runtime.ParamLocationPath, resourceTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureInventory/v1/resourceTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllVersionsWithResponse request
	GetAllVersionsWithResponse(ctx context.Context, params *GetAllVersionsParams, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error)

	// GetCloudInfoWithResponse request
	GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error)

	// GetMinorVersionsWithResponse request
	GetMinorVersionsWithResponse(ctx context.Context, params *GetMinorVersionsParams, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error)

	// GetDeploymentManagersWithResponse request
	GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error)

	// GetDeploymentManagerWithResponse request
	GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error)

	// GetResourcePoolsWithResponse request
	GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error)

	// GetResourcePoolWithResponse request
	GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceTypesWithResponse request
	GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error)

	// GetResourceTypeWithResponse request
	GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)
}

type GetAllVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAllVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudInfoResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OCloudInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCloudInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinorVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMinorVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinorVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentManagerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentManager
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeploymentManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourcePool
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Resource
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceType
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllVersionsWithResponse request returning *GetAllVersionsResponse
func (c *ClientWithResponses) GetAllVersionsWithResponse(ctx context.Context, params *GetAllVersionsParams, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error) {
	rsp, err := c.GetAllVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVersionsResponse(rsp)
}

// GetCloudInfoWithResponse request returning *GetCloudInfoResponse
func (c *ClientWithResponses) GetCloudInfoWithResponse(ctx context.Context, params *GetCloudInfoParams, reqEditors ...RequestEditorFn) (*GetCloudInfoResponse, error) {
	rsp, err := c.GetCloudInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudInfoResponse(rsp)
}

// GetMinorVersionsWithResponse request returning *GetMinorVersionsResponse
func (c *ClientWithResponses) GetMinorVersionsWithResponse(ctx context.Context, params *GetMinorVersionsParams, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error) {
	rsp, err := c.GetMinorVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinorVersionsResponse(rsp)
}

// GetDeploymentManagersWithResponse request returning *GetDeploymentManagersResponse
func (c *ClientWithResponses) GetDeploymentManagersWithResponse(ctx context.Context, params *GetDeploymentManagersParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagersResponse, error) {
	rsp, err := c.GetDeploymentManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagersResponse(rsp)
}

// GetDeploymentManagerWithResponse request returning *GetDeploymentManagerResponse
func (c *ClientWithResponses) GetDeploymentManagerWithResponse(ctx context.Context, deploymentManagerId DeploymentManagerId, params *GetDeploymentManagerParams, reqEditors ...RequestEditorFn) (*GetDeploymentManagerResponse, error) {
	rsp, err := c.GetDeploymentManager(ctx, deploymentManagerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentManagerResponse(rsp)
}

// GetResourcePoolsWithResponse request returning *GetResourcePoolsResponse
func (c *ClientWithResponses) GetResourcePoolsWithResponse(ctx context.Context, params *GetResourcePoolsParams, reqEditors ...RequestEditorFn) (*GetResourcePoolsResponse, error) {
	rsp, err := c.GetResourcePools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolsResponse(rsp)
}

// GetResourcePoolWithResponse request returning *GetResourcePoolResponse
func (c *ClientWithResponses) GetResourcePoolWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, reqEditors ...RequestEditorFn) (*GetResourcePoolResponse, error) {
	rsp, err := c.GetResourcePool(ctx, resourcePoolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcePoolResponse(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, resourcePoolId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourcePoolId ResourcePoolId, resourceId ResourceId, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourcePoolId, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceTypesWithResponse request returning *GetResourceTypesResponse
func (c *ClientWithResponses) GetResourceTypesWithResponse(ctx context.Context, params *GetResourceTypesParams, reqEditors ...RequestEditorFn) (*GetResourceTypesResponse, error) {
	rsp, err := c.GetResourceTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypesResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, resourceTypeId ResourceTypeId, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, resourceTypeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// ParseGetAllVersionsResponse parses an HTTP response from a GetAllVersionsWithResponse call
func ParseGetAllVersionsResponse(rsp *http.Response) (*GetAllVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudInfoResponse parses an HTTP response from a GetCloudInfoWithResponse call
func ParseGetCloudInfoResponse(rsp *http.Response) (*GetCloudInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OCloudInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetMinorVersionsResponse parses an HTTP response from a GetMinorVersionsWithResponse call
func ParseGetMinorVersionsResponse(rsp *http.Response) (*GetMinorVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinorVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagersResponse parses an HTTP response from a GetDeploymentManagersWithResponse call
func ParseGetDeploymentManagersResponse(rsp *http.Response) (*GetDeploymentManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDeploymentManagerResponse parses an HTTP response from a GetDeploymentManagerWithResponse call
func ParseGetDeploymentManagerResponse(rsp *http.Response) (*GetDeploymentManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentManager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolsResponse parses an HTTP response from a GetResourcePoolsWithResponse call
func ParseGetResourcePoolsResponse(rsp *http.Response) (*GetResourcePoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcePoolResponse parses an HTTP response from a GetResourcePoolWithResponse call
func ParseGetResourcePoolResponse(rsp *http.Response) (*GetResourcePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypesResponse parses an HTTP response from a GetResourceTypesWithResponse call
func ParseGetResourceTypesResponse(rsp *http.Response) (*GetResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Tkc4jx8f/zcAAP///ij7m3dyAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../common/api/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
